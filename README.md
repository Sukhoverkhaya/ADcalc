# PulseDetector
Оффлайн алгоритм:
Вход - амплитуды отсчетов 3-х каналов + метки алгоритма управления
Промежуточный выход: параметризованные события (тоны и пульсации; 2 вектора структур)
Выход - границы АД на накачке и спуске (вектор структур)

Структура одного элемента входных данных (3 канала + метки алгоритма управления, получаем с шагом в период дискретизации)
struct InputPack{ 
	float ecg; – амплитуда сигнала ЭКГ
	float pres; – амплитуда давления
	float tone; – амплитуда тонов
	float ca; – код метки алгоритма управления
};

Вход: InputPack input[] – фрагмент сигнала в границах между ближайшими метками алгоритма управления са, соответствующими началу накачки и концу спуска воздуха.

Структура одного элемента выходных данных детектора для каналов ЭКГ и тонов:
struct Event{
	int pos      - позиция события
	float amp  - амплитуда события
};

Структура одного элемента выходных данных детектора для пульсаций:
struct Pulse{
	struct Event min
	struct Event max
};

Первичный детектор: 
Event/Pulse detector(float input[]*все отсчеты соответствующего сигнала из входного вектора*){
	Event/Pulse ev[]  // вектор для всех найденных событий
	// детекция событий…//
	return ev
};

Параметризатор:
struct ECGEv{       // Детектированное собитие: элемент QRS (зубец R?)
    float amp;         // Амплитуда
    float ewidth;     // Энерг ширина
    float prem;      // Преждевеременность
    int rejres;        // Код причины браковки
};

struct PresEv{      // Детектированное событие: пульсация (фронт) ?? Заполняется и возвращается, только когда найден максимум?
    float amin;       // Амплитуда минимума
    float amax;      // Амплитуда максимума
    float prem;      // Преждевеременность
    int rejres;        // Код причины браковки
};

struct ToneEv{          // Детектированное событие: тон
    float amp;             // Амплитуда
    float prenoise;     // Шум до
    float postnoise;   // Шум после
    float ewidth;        // Энерг ширина
    float prem;          // Преждевеременность
    int rejres;           // Код причины браковки
};

ECGEv/PresEv/ToneEv parametrizer(Event/Pulse events){
	N - кол-во событий на входе
	ECGEv/PresEv/ToneEv output[N] // вектор для всех параметризованных
	// параметризация…//
	return output
};

Определение границ САД и ДАД на участке сигнала:
struct AD{
	struct Event SAD;
	struct Event DAD;
};
struct fullAD{
	struct AD pump;  // САД и ДАД на накачке
	struct AD desc;   // САД и ДАД на спуске
};

Выход алгоритма определения АД:
struct OutputAD{
	struct fullAD pres; // по пульсациям
	struct fullAD tone; // по тонам
};
pres - фрагмент сигнала давления на рассматриваемом участке
pulseparam - параметризованные пульсации
toneparam - параметризованные тона;
bounds - границы начала и окончания накачки и спуска, рассчитанные с использованием меток алгоритма управления.
OutputAD calcAD(pres, pulseparam, toneparam, bounds){
	return AD
};

Онлайн алгоритм:

Структура входных данных (3 канала + метки алгоритма управления, получаем с шагом в период дискретизации)
struct InputPack{ 
	float ecg; – амплитуда сигнала ЭКГ
	float pres; – амплитуда давления
	float tone; – амплитуда тонов
	float ca; – код метки алгоритма управления
};

Для каждого канала свой детектор, который принимает значение амплитуды из соответствующего поля InputPack, состояние функции (State, чтобы не тащить буфер?) и возвращает метку события (есть/нет)

struct State{
	…
};

int detector(float amplitude, struct State state){
	return flag
}

(Каждому набору входных значений соответствует выход детектора)

Там, где флаг события устанавливается в 1, с некоторой задержкой в соответствующий вектор структур складывается параметризованное событие.

*соответствующая структура* parametrizer(*набор точек с метками событий*??){
	*соответствующая структура* result = …
	return result
};
struct ECGEv{       // Детектированное собитие: элемент QRS (зубец R?)
    float amp;         // Амплитуда
    float ewidth;     // Энерг ширина
    float prem;      // Преждевеременность
    int rejres;        // Код причины браковки
};

struct PresEv{      // Детектированное событие: пульсация (фронт) ?? Заполняется и возвращается, только когда найден максимум?
    float amin;       // Амплитуда минимума
    float amax;      // Амплитуда максимума
    float prem;      // Преждевеременность
    int rejres;        // Код причины браковки
};

struct ToneEv{          // Детектированное событие: тон
    float amp;             // Амплитуда
    float prenoise;     // Шум до
    float postnoise;   // Шум после
    float ewidth;        // Энерг ширина
    float prem;          // Преждевеременность
    int rejres;           // Код причины браковки
};

